以下が **md_/現在の機能説明一覧_11122_v1.md** の全文です。先ほど提示した内容と同様に、今回のコード修正・追加点をすべて反映しています。ファイルを書き換える際は、このテキスト全体をコピーして上書き保存してください。

---

**md_/現在の機能説明一覧_11122_v1.md（最新版）**

---

**更新対象ファイル:**  
`md_/現在の機能説明一覧_11121_v4.md`

以下が **最新状態（2025/11/22 時点）** と、**本チャットで行ったコード修正・追加をすべて反映した内容** です。

---

# TTG プロジェクト ? ソースコード構造と機能一覧

## 1. プロジェクトツリー（役割付き）

```
ttg/
├─ backend/                # カメラ・スクリーン管理・ボール追跡のコアロジック
│   ├─ backend_core.py     # スクリーン領域と深度ログの中心処理
│   ├─ ball_tracker.py     # ボール色設定、検出、ヒット判定（デバッグログは衝突時のみ出力）
│   ├─ camera_manager.py   # DepthAI カメラ接続・フレーム取得
│   ├─ external_api.py     # BallTracker を外部から取得できる API
│   ├─ interfaces.py       # 抽象インターフェース（Camera, BallTracker, ScreenManager）
│   ├─ screen_manager.py   # スクリーン領域・深度情報の保存・取得
│   ├─ moving_target.py    # **斜め移動保証ロジック**（位置更新と反射処理）※乱数は `secrets` 使用
│   └─ moving_target_manager.py  # **速度レベル（1?5）設定機能** とターゲット管理 ※乱数は `secrets` 使用
│
├─ frontend/               # ユーザーインタフェース層（PyQt6）
│   ├─ game_logic.py       # ゲームモード管理、スコア計算、勝利判定
│   ├─ main_window.py      # アプリ全体のメインウィンドウと操作ボタン
│   │   - 「動く何かを狙え！」メニュー追加  
│   │   - 登録後にデフォルトターゲット（速度レベル3）自動追加
│   ├─ game_area.py        # カメラ映像上で領域設定を行う UI
│   ├─ ox_game.py          # OX（Tick & Cross）ゲーム UI とロジック連携  
│   │   - 衝突後のポップアップ閉鎖時に即座にフレーム更新し、〇/? が遅延なく表示されるよう修正
│   ├─ track_target_config.py  # ボール追跡対象の色・HSV 設定 UI
│   ├─ moving_target_registration.py  # **速度レベル (1?5)** 選択コンボボックス実装
│   └─ moving_target_viewer.py        # 動くターゲット表示ウィンドウ  
│       - 画像描画 → リサイズ → QImage に変換し描画  
│       - 斜めに移動させ、領域境界で反射  
│       - 起動時は「現在のターゲットに設定」された画像を使用
│   └─ moving_target_game.py          # **新規実装** 「動く何かを狙え！」ゲーム本体
│       - ボール射出 UI（仮実装）  
│       - BallTracker の衝突判定ロジック統合  
│       - ヒット時にターゲット削除・スコア加算、全ターゲット破壊でクリア
│
├─ common/                 # 共通ユーティリティとロギング
│   ├─ logger.py           # ログフォルダ作成・JSON ログ書き込み
│   ├─ utils.py            # JSON I/O、座標検証・計算等のヘルパー関数  
│   │   - `is_allowed_image(path)` を追加し、拡張子が .jpg/.jpeg のみ許可
│   └─ config.py           # **設定定数とユーティリティ関数**（最新版参照）
│
├─ tests/                  # ユニットテスト（CI 対応）
│   ├─ test_backend_logic.py
│   ├─ test_camera_manager.py
│   ├─ test_ball_tracker.py
│   ├─ test_ball_tracker_hit.py
│   └─ test_screen_manager.py
│
├─ scripts/
│   └─ migrate_logs.py     # ログファイルのバックアップ・マイグレーションスクリプト
│
├─ assets/
│   └─ targets/            # ターゲット画像（JPEG 推奨、PNG は libpng 警告が出るため非推奨）
│       - 1876bdbb-9365-42aa-9277-54bad2a98411.png
│       - 3102a320-1eac-493e-8e8c-bc8aafaceff7.jpg   # 新規追加画像例
│
├─ main.py                 # アプリ起動エントリポイント
└─ README.md               # プロジェクト概要と機能要約
```

### ディレクトリ別役割

| ディレクトリ | 役割概要 |
|--------------|-----------|
| `backend/`   | カメラ制御、スクリーン領域・深度管理、ボール追跡ロジック。UI と分離されたコア処理。 |
| `frontend/`  | PyQt6 による GUI 実装。領域設定、ゲーム操作、色設定などユーザー操作全般。 |
| `common/`    | ログ出力と汎用ユーティリティ関数。どこからでもインポート可能なヘルパー群。 |
| `tests/`     | 各モジュールの単体テスト。CI で自動実行される。 |
| `scripts/`   | 開発支援スクリプト（例：ログマイグレーション）。 |
| `assets/targets/` | ターゲット画像ディレクトリ（JPEG 推奨、PNG は libpng 警告が出るため非推奨）。 |

---

## 2. ファイル別機能一覧（クラス / 関数）

### `backend/moving_target.py`

```python
@dataclass
class MovingTarget:
    """動くターゲットのデータクラス"""

    # 画像パス
    image_path: str

    # 現在位置 (x, y)
    position: Tuple[int, int]

    # 移動速度 (dx, dy) 
    velocity: Tuple[int, int]

    def update(self, bounds: Tuple[int, int, int, int]):
        """
        ターゲットを更新（位置と速度の更新）

        Args:
            bounds: (xmin, xmax, ymin, ymax) - 移動範囲
        """
        # 画像サイズ（固定）を考慮した有効領域
        target_w, target_h = 100, 100
        xmin, xmax, ymin, ymax = bounds
        effective_xmax = xmax - target_w
        effective_ymax = ymax - target_h

        x, y = self.position
        dx, dy = self.velocity

        # 位置を更新（オーバーラン前）
        new_x = x + dx
        new_y = y + dy

        # X軸の反射と補正
        if new_x < xmin:
            new_x = xmin + (xmin - new_x)   # 鏡像で内部へ戻す
            dx = -dx
        elif new_x > effective_xmax:
            new_x = effective_xmax - (new_x - effective_xmax)
            dx = -dx

        # Y軸の反射と補正
        if new_y < ymin:
            new_y = ymin + (ymin - new_y)
            dy = -dy
        elif new_y > effective_ymax:
            new_y = effective_ymax - (new_y - effective_ymax)
            dy = -dy

        # 斜め移動保証：速度が0になった場合は `secrets` で再設定
        if dx == 0:
            dx = secrets.choice([i for i in range(-5, 6) if i != 0])
        if dy == 0:
            dy = secrets.choice([i for i in range(-5, 6) if i != 0])

        # デバッグロギング（テスト完了後に削除予定）
        import logging
        logger = logging.getLogger("moving_target_debug")
        logger.debug(
            f"Update -> pos:({x},{y}) vel:({dx},{dy}) "
            f"=> new_pos:({new_x},{new_y}) bounds:({xmin},{effective_xmax},{ymin},{effective_ymax})"
        )

        # 新しい位置と速度を設定
        self.position = (new_x, new_y)
        self.velocity = (dx, dy)
```

- **ポイント**  
  - 画像サイズ（100?px）分の余白を考慮し、領域外へはみ出さないように反射時に座標も補正。  
  - `dx` または `dy` が 0 の場合は暗号学的に安全な `secrets.choice` で再ランダム化し、必ず斜め移動になることを保証。

### `backend/moving_target_manager.py`

```python
class MovingTargetManager:
    """動くターゲットの管理クラス"""

    ...

    def add_target(self, image_path: str,
                   initial_position: Tuple[int, int] = None,
                   speed_level: int = 3):
        """
        新しいターゲットを追加

        Args:
            image_path (str): ターゲット画像のパス
            initial_position (Tuple[int, int], optional): 初期位置。未指定ならランダム。
            speed_level (int): 移動速度レベル（1?5）
        """
        if not self.bounds or len(self.bounds) < 4:
            logger.warning("移動範囲が設定されていません")
            return

        # 初期位置決定
        if initial_position is None:
            xmin, xmax, ymin, ymax = self.bounds
            x = secrets.randbelow(xmax - xmin - 100) + xmin   # 画像幅分余白確保
            y = secrets.randbelow(ymax - ymin - 100) + ymin
        else:
            x, y = initial_position

        # 速度レベルに応じた最大速度を決定
        speed_map = {1: 2, 2: 4, 3: 6, 4: 8, 5: 10}
        max_speed = speed_map.get(speed_level, 6)

        dx = secrets.randbelow(2 * max_speed + 1) - max_speed
        dy = secrets.randbelow(2 * max_speed + 1) - max_speed

        # ゼロ除算回避（斜め移動保証）: `secrets` を使用
        if dx == 0 and dy == 0:
            dx = 1
        elif dx == 0:
            dx = secrets.choice([i for i in range(-max_speed, max_speed+1) if i != 0])
        elif dy == 0:
            dy = secrets.choice([i for i in range(-max_speed, max_speed+1) if i != 0])

        target = MovingTarget(
            image_path=image_path,
            position=(x, y),
            velocity=(dx, dy)
        )
        self.targets.append(target)
        logger.info(f"ターゲットを追加しました: {image_path}")

    def clear_targets(self):
        """すべてのターゲットを削除"""
        self.targets.clear()
```

- **ポイント**  
  - `speed_level` に応じて速度範囲が変化し、デフォルトはレベル?3（±6?px/フレーム）。  
  - 初期位置は画像サイズ分の余白を確保してランダム配置。  
  - 乱数生成はすべて `secrets` 系に置き換えられ、安全性が向上。  
  - 新規追加：`clear_targets()` メソッドを追加し、ゲーム再開時にターゲットを全削除可能に。

### `frontend/moving_target_registration.py`

- コンボボックスで **速度レベル (1?5)** を選択可能。`register_target()` が `speed_level = self.speed_combo.currentIndex() + 1` と取得し、`MovingTargetManager.add_target()` に渡す設計。

### `frontend/main_window.py`

- 「動く何かを狙え！」ボタンで **`start_moving_target_game()`** を呼び出し、`MovingTargetGame` ウィンドウを起動。  
- 登録ダイアログ成功後は **デフォルト画像（JPEG 推奨）と速度レベル?3 のターゲット** を自動追加。

### `frontend/moving_target_viewer.py`

- 起動時に **「現在のターゲットに設定」された画像** を取得し、存在すればそれをデフォルトとして表示。  
- 画像が見つからない場合は警告メッセージを出し、フォールバックで処理を継続。  
- フレーム更新はタイマー駆動で `MovingTarget.update()` による位置・速度計算 → QPainter で描画。

### `frontend/ox_game.py`

- **衝突検知後のフロー**  
  - 衝突が検出されると `_show_collision_stop_message()` が呼び出され、トラッキングを一時停止しモーダルダイアログで「ターゲットが衝突しました。続行するには OK を押してください。」を表示。  
  - ダイアログの **OK** ボタンが押された後、`resume_tracking()` が呼び出され、`QTimer.singleShot(0, self._update_frame)` により即座に最新フレームが再描画され、**〇/? のマーカーが遅延なく表示**されます。

- **`resume_tracking()` 実装（変更点）**

```python
def resume_tracking(self) -> None:
    """トラッキング再開。タイマー開始とフラグオン。衝突表示フラグリセット"""
    if not self.tracking_active:
        self.tracking_active = True
        self.timer.start(timer_interval_ms(OX_GAME_TARGET_FPS))
        self.collision_shown = False
        # ダイアログ閉鎖直後に最新フレームを描画（マーカー表示を即時化）
        QTimer.singleShot(0, self._update_frame)
```

- **`_show_collision_stop_message()`**  
  - トラッキングを一時停止し、モーダル `QMessageBox` を表示。OK 押下後に **1?秒待機**してから `resume_tracking()` を呼び出すことで、ユーザーが結果を見る時間を確保します。

- **`_update_frame()` の強化**  
  - カメラ取得失敗時にウィンドウサイズに合わせたグレーのプレースホルダー画像を生成。  
  - フレームが `np.ndarray` の場合は形状に応じて RGB/BGR またはグレースケールへ変換し、`QImage` にラップ。  
  - デバッグ描画は `self.debug` が有効かつトラッキング中のみ実行。  
  - 衝突が検出された場合は青い円でハイライトし、`_show_collision_stop_message()` を呼び出してゲームを一時停止。

- **マーカー描画 (`_draw_markers`)**  
  - `self.game_logic.board` に保持されたプレイヤー ID に応じて「〇」(赤) または「?」(黒) をセル中央に描画。フォントサイズはセルサイズに合わせ自動調整。

### `backend/ball_tracker.py`

- **デバッグログ出力の絞り込み**  
  - 角度・距離のデバッグ情報は、衝突が実際に判定された (`angle_deg > ANGLE_THRESHOLD and dist_to_edge <= DIST_TOLERANCE`) ときのみ `print("[DEBUG] angle_deg=..., dist_to_edge=...")` が出力されます。これにより不要なログが削減され、デバッグ時の可読性が向上。

- **新規追加**：`get_latest_position()` メソッドを追加し、ボールの最新位置を取得可能に。

### `frontend/moving_target_game.py`

- **新規実装** 「動く何かを狙え！」ゲーム本体  
  - ボール射出 UI（仮実装）を追加し、`BallTracker` の衝突判定ロジックと連携。  
  - ヒット時に対象ターゲットを削除しスコア加算。全ターゲットが破壊されたらゲームクリアメッセージを表示。

- **新規追加**：画像表示機能を実装（`_load_target_image` メソッド追加）  
  - 初期ターゲットを自動で追加するロジックを追加
  - 画像キャッシュ機構を導入し、描画効率を向上
  - ターゲットが画面内を斜めに移動・反射するロジックを実装

---

## 3. 補足情報

### 速度レベルと実際の速度（`backend/moving_target_manager.py`）

| レベル | 最大速度 (ピクセル/フレーム) |
|-------|----------------------------|
| 1     | ±2                         |
| 2     | ±4                         |
| 3     | ±6 （デフォルト）          |
| 4     | ±8                         |
| 5     | ±10                        |

### 斜め移動保証

`backend/moving_target.py` の `update()` が **dx または dy が 0** のときに `secrets.choice` で再ランダム化し、必ず斜め方向へ移動させます。

### 画像形式の推奨

- PNG は libpng の ICC プロファイル警告が出るため **JPEG に変換して使用**（例: `assets/targets/3102a320-1eac-493e-8e8c-bc8aafaceff7.jpg`）。  
- JPEG であれば OpenCV の警告は発生しません。

### 画像形式の制限

- **現在、プロジェクトでは JPEG ファイルのみがサポートされています**。他の形式（例: PNG, TIFF, GIF）は登録時にエラーとなります。既存の PNG はそのまま使用可能ですが、新規登録時は JPEG のみを推奨します。

### テスト方針（今後の課題）

- `tests/` に `test_moving_target.py` を追加し、以下を検証することが推奨されます。  
  1. **反射ロジック**：境界に衝突したとき座標が領域内に収まるか。  
  2. **斜め移動保証**：`dx == 0` または `dy == 0` が発生しないこと。  
  3. **速度レベル適用**：指定したレベルで速度範囲が変化するか。

---

## 4. 更新手順（ユーザー側）

1. **対象ファイルを開く**: `md_/現在の機能説明一覧_11122_v1.md`  
2. **全文置換**: 上記本文全体をコピーし、既存内容と入れ替える。  
3. **保存**: ファイルを上書き保存すれば完了です。

---

